<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SimSpread.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://cvigilv.github.io/SimSpread.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="SimSpread.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">SimSpread.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome to SimSpread.jl</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial/getting-started/">Getting started</a></li><li><a class="tocitem" href="../tutorial/fishers-flowers/">Fisher&#39;s flowers</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Core"><span>Core</span></a></li><li><a class="tocitem" href="#Cross-validation"><span>Cross-validation</span></a></li><li><a class="tocitem" href="#Performance-assessment"><span>Performance assessment</span></a></li><li><a class="tocitem" href="#Miscellaneous-utilities"><span>Miscellaneous utilities</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cvigilv/SimSpread.jl/blob/main/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Core"><a class="docs-heading-anchor" href="#Core">Core</a><a id="Core-1"></a><a class="docs-heading-anchor-permalink" href="#Core" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SimSpread.spread" href="#SimSpread.spread"><code>SimSpread.spread</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spread(G::AbstractMatrix{Float64})</code></pre><p>Calculate the transfer matrix for the adyacency matrix of the trilayered feature-source-target network.</p><p><strong>Arguments</strong></p><ul><li><code>G::AbstractMatrix{Float64}</code>: Trilayered feature-source-target network adjacency matrix.</li></ul><p><strong>Extended help</strong></p><p>Potential interactions between nodes in a graph can be identified by using resource diffusion processes in the feature-source-target network, namely aforementioned graph <code>G</code>. For each node nᵢ in the network, it has initial resources located in both its neighboring nodes and its features. Initially, each feature and each neighboring node of nᵢ equally spread their resources to neighboring nodes. Subsequently, each of those nodes equally spreads its resources to neighbor nodes. Thus, nᵢ will obtain final resources located in several neighboring nodes, suggesting that nᵢ may have potential interactions with these nodes.</p><p><strong>References</strong></p><ol><li>Wu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012</li><li>Vigil-Vásquez &amp; Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L339-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.cutoff" href="#SimSpread.cutoff"><code>SimSpread.cutoff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cutoff(x::T, α::T, weighted::Bool=false) where {T&lt;:AbstractFloat}</code></pre><p>Transform <code>x</code> based in SimSpread&#39;s similarity cutoff function.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractFloat</code> : Value to transform</li><li><code>α::AbstractFloat</code> : Similarity cutoff</li><li><code>weighted::Bool</code> : Apply weighting function to outcome (default = false)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L27-L36">source</a></section><section><div><pre><code class="nohighlight hljs">cutoff(M::AbstractVecOrMat{T}, α::T, weighted::Bool=false) where {T&lt;:AbstractFloat}</code></pre><p>Transform the vector or matrix <code>X</code> based in SimSpread&#39;s similarity cutoff function.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractVecOrMat{AbstractFloat}</code> : Matrix or Vector to transform</li><li><code>α::AbstractFloat</code> : Similarity cutoff</li><li><code>weighted::Bool</code> : Apply weighting function to outcome (default = false)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.cutoff!" href="#SimSpread.cutoff!"><code>SimSpread.cutoff!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cutoff!(x::T, α::T, weighted::Bool=false) where {T&lt;:AbstractFloat}</code></pre><p>Transform, in place, <code>x</code> based in SimSpread&#39;s similarity cutoff function.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractFloat</code> : Value to transform</li><li><code>α::AbstractFloat</code> : Similarity cutoff</li><li><code>weighted::Bool</code> : Apply weighting function to outcome (default = false)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L62-L71">source</a></section><section><div><pre><code class="nohighlight hljs">cutoff!(X::AbstractVecOrMat{T}, α::T, weighted::Bool=false) where {T&lt;:AbstractFloat}</code></pre><p>Transform, in place, the vector or matrix <code>X</code> based in SimSpread&#39;s similarity cutoff function.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractVecOrMat{AbstractFloat}</code> : Matrix or Vector to transform</li><li><code>α::AbstractFloat</code> : Similarity threshold</li><li><code>weighted::Bool</code> : Apply weighting function to outcome (default = false)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L77-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.featurize" href="#SimSpread.featurize"><code>SimSpread.featurize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">featurize(X::NamedArray, α::AbstractFloat, weighted::Bool=true)</code></pre><p>Transform the feature matrix <code>X</code> into a SimSpread feature matrix.</p><p><strong>Arguments</strong></p><ul><li><code>X::NamedArray</code>: Continuous feature matrix</li><li><code>α::AbstractFloat</code>: Featurization cutoff</li><li><code>weighted::Bool</code> : Apply weighting function to outcome (default = true)</li></ul><p><strong>References</strong></p><ol><li>Vigil-Vásquez &amp; Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L91-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.featurize!" href="#SimSpread.featurize!"><code>SimSpread.featurize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">featurize!(X::NamedArray, α::AbstractFloat, weighted::Bool=true)</code></pre><p>Transform, in place, the feature matrix <code>X</code> into a SimSpread feature matrix.</p><p><strong>Arguments</strong></p><ul><li><code>X::NamedArray</code> : Continuous feature matrix</li><li><code>α::AbstractFloat</code> : Featurization cutoff</li><li><code>weighted::Bool</code> : Apply weighting function to outcome (default = true)</li></ul><p><strong>References</strong></p><ol><li>Vigil-Vásquez &amp; Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L114-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.construct" href="#SimSpread.construct"><code>SimSpread.construct</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct(y::NamedMatrix, X::NamedMatrix, queries::AbstractVector)</code></pre><p>Construct the query-feature-source-target network for <em>de novo</em> network-based inference prediction and return adjacency matrix.</p><p><strong>Arguments</strong></p><ul><li><code>y::NamedMatrix</code>: Source-target bipartite network adjacency matrix</li><li><code>X::NamedMatrix</code>: Source-feature bipartite adjacency matrix</li><li><code>queries::AbstractVector</code>: Source nodes to use as query</li></ul><p><strong>Extended help</strong></p><p>This implementation is intended for k-fold or leave-one-out cross-validation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L134-L147">source</a></section><section><div><pre><code class="nohighlight hljs">construct(ys::T, Xs::T) where {T&lt;:Tuple{NamedMatrix,NamedMatrix}}</code></pre><p>Construct the query-feature-source-target network for <em>de novo</em> network-based inference prediction and return adjacency matrix.</p><p><strong>Arguments</strong></p><ul><li><code>dts::Tuple{NamedMatrix,NamedMatrix}</code> : Source-target bipartite graph adjacency matrices</li><li><code>dfs::Tuple{NamedMatrix,NamedMatrix}</code> : Source-feature bipartite graph adjacency matrices</li></ul><p><strong>Extended help</strong></p><p>This implementations is intended for time-split cross-validation or manual construction of query network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L203-L216">source</a></section><section><div><pre><code class="nohighlight hljs">construct(ytrain::T, ytest::T, Xtrain::T, Xtest::T) where {T&lt;:NamedMatrix}</code></pre><p>Construct the query-feature-source-target network for <em>de novo</em> network-based inference prediction and return adjacency matrix.</p><p><strong>Arguments</strong></p><ul><li><code>ytrain::NamedMatrix</code> : Training source-target bipartite graph adjacency matrix</li><li><code>ytest::NamedMatrix</code> : Test source-target bipartite graph adjacency matrix</li><li><code>Xtrain::NamedMatrix</code> : Training source-feature bipartite graph adjacency matrix</li><li><code>Xtest::NamedMatrix</code> : Test source-feature bipartite graph adjacency matrix</li></ul><p><strong>Extended help</strong></p><p>This implementations is intended for time-split cross-validation or manual construction of query network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L278-L293">source</a></section><section><div><pre><code class="nohighlight hljs">construct(y::NamedMatrix, X::NamedMatrix)</code></pre><p>Construct the feature-source-target network for network-based inference prediction and return adjacency matrix.</p><p><strong>Arguments</strong></p><ul><li><code>y::NamedMatrix</code> : Source-target bipartite graph adjacency matrix</li><li><code>X::NamedMatrix</code> : Source-feature bipartite graph adjacency matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L298-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.predict" href="#SimSpread.predict"><code>SimSpread.predict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">predict(I::Tuple{T,T}, ytest::T; GPU::Bool=false) where {T&lt;:NamedMatrix}</code></pre><p>Predict interactions between query and target nodes using <em>de novo</em> network-based inference model proposed by Wu, et al (2016).</p><p><strong>Arguments</strong></p><ul><li><code>I::Tuple{NamedMatrix,NamedMatrix}</code>: Feature-source-target trilayered adjacency matrices</li><li><code>ytest::NamedMatrix</code>: Query-target bipartite adjacency matrix</li><li><code>GPU::Bool</code>: Use GPU acceleration for calculation (default = false)</li></ul><p><strong>References</strong></p><ol><li>Wu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012</li><li>Vigil-Vásquez &amp; Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L383-L401">source</a></section><section><div><pre><code class="nohighlight hljs">predict(A::T, ytrain::T; GPU::Bool=false) where {T&lt;:NamedMatrix}</code></pre><p>Predict interactions between query and target nodes using <em>de novo</em> network-based inference model proposed by Wu, et al (2016).</p><p><strong>Arguments</strong></p><ul><li><code>A::NamedMatrix</code>: Feature-source-target trilayered adjacency matrix</li><li><code>ytrain::NamedMatrix</code>: Source-target bipartite adjacency matrix</li><li><code>GPU::Bool</code>: Use GPU acceleration for calculation (default = false)</li></ul><p><strong>References</strong></p><ol><li>Wu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012</li><li>Vigil-Vásquez &amp; Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L427-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.save" href="#SimSpread.save"><code>SimSpread.save</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">save(filepath::String, yhat::NamedMatrix, y::NamedMatrix; delimiter::Char=&#39;	&#39;)</code></pre><p>Store predictions as a table in the given file path.</p><p><strong>Arguments</strong></p><ul><li><code>filepath::String</code>: Output file path</li><li><code>yhat::NamedArray</code>: Predicted source-target bipartite adjacency matrix</li><li><code>y::NamedArray</code>: Ground-truth source-target bipartite adjacency matrix</li><li><code>delimiter::Char</code>: Delimiter used to write table (default = &#39;\t&#39;)</li></ul><p><strong>Extended help</strong></p><p>Table format is:</p><pre><code class="nohighlight hljs">fold, source, target, score, label</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L486-L502">source</a></section><section><div><pre><code class="nohighlight hljs">save(filepath::String, fidx::Int64, yhat::NamedMatrix, y::NamedMatrix; delimiter::Char=&#39;	&#39;)</code></pre><p>Store cross-valudation predictions as a table in the given file path.</p><p><strong>Arguments</strong></p><ul><li><code>filepath::String</code>: Output file path</li><li><code>fidx::Int64</code>: Numeric fold ID</li><li><code>yhat::NamedArray</code>: Predicted source-target bipartite adjacency matrix</li><li><code>y::NamedArray</code>: Ground-truth source-target bipartite adjacency matrix</li><li><code>delimiter::Char</code>: Delimiter used to write table (default = &#39;\t&#39;)</li></ul><p><strong>Extended help</strong></p><p>Table format is:</p><pre><code class="nohighlight hljs">fold, source, target, score, label</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L524-L541">source</a></section></article><h2 id="Cross-validation"><a class="docs-heading-anchor" href="#Cross-validation">Cross-validation</a><a id="Cross-validation-1"></a><a class="docs-heading-anchor-permalink" href="#Cross-validation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.split" href="#Base.split"><code>Base.split</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Base.split(y::NamedArray, k::Int64; seed::Int64=1)</code></pre><p>Split source nodes in <code>y</code> into <code>k</code> groups for cross-validation.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractMatrix</code>: Drug-Target rectangular adjacency matrix.</li><li><code>k::Int64</code>: Number of groups to use in data splitting.</li><li><code>seed::Int64</code>: Seed used for data splitting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.clean!" href="#SimSpread.clean!"><code>SimSpread.clean!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clean!(yhat::NamedArray, A::NamedArray, y::NamedArray)</code></pre><p>Flag, in place, erroneous prediction from cross-validation splitting.</p><p><strong>Arguments</strong></p><ul><li><code>yhat::NamedArray</code>: Predicted source-target bipartite adjacency matrix</li><li><code>A::NamedArray</code>: Initial resource source-target resources adjacency matrix</li><li><code>y::NamedArray</code>: Ground-truth source-target bipartite adjacency matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/simspread.jl#L468-L477">source</a></section></article><h2 id="Performance-assessment"><a class="docs-heading-anchor" href="#Performance-assessment">Performance assessment</a><a id="Performance-assessment-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-assessment" title="Permalink"></a></h2><p>Several evaluation metrics are implemented in the package, which can be that can be classified into three groups: (i) overall performance, (ii) early recognition, and (iii) binary prediction  performance.</p><h3 id="Overall-performance"><a class="docs-heading-anchor" href="#Overall-performance">Overall performance</a><a id="Overall-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Overall-performance" title="Permalink"></a></h3><p>This metrics represent classical evaluation metrics that make use of the complete list of prediction to assess predictive performance.</p><article class="docstring"><header><a class="docstring-binding" id="SimSpread.AuPRC" href="#SimSpread.AuPRC"><code>SimSpread.AuPRC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AuPRC(y::AbstractVector{Bool}, yhat::AbstractVector)</code></pre><p>Area under the Precision-Recall curve using the trapezoidal rule.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractArray</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractArray</code>: Prediction scores.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L65-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.AuROC" href="#SimSpread.AuROC"><code>SimSpread.AuROC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AuROC(y::AbstractVector{Bool}, yhat::AbstractVector)</code></pre><p>Area under the Receiver Operator Characteristic curve using the trapezoidal rule.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractArray</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractArray</code>: Prediction scores.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L40-L48">source</a></section></article><h3 id="Early-recognition-performance"><a class="docs-heading-anchor" href="#Early-recognition-performance">Early recognition performance</a><a id="Early-recognition-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Early-recognition-performance" title="Permalink"></a></h3><p>Due to the roots of SimSpread (target prediction in drug discovery), we include evaluation metrics that aim to assess predictive performance of the best predictions obtained from a model.</p><p>In virtual screening, only the best predictions obtained from a model are selected for posterior experimental validation. Therefore, understanding the predictive performance of a model for these predictions is essential to (1) make accurate predictions that will translate to biological activity and (2) understand the limitations of the model. The metrics discussed here can be evaluated at a given cut-off rank, considering only the topmost results returned by the predictive method, hence informing of the predictive performance of the model for only the best predictions.</p><article class="docstring"><header><a class="docstring-binding" id="SimSpread.recallatL" href="#SimSpread.recallatL"><code>SimSpread.recallatL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recallatL(y, yhat, L)</code></pre><p>Get recall@L as proposed by Wu, et al (2017).</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractVector</code>: Prediction score.</li><li><code>L::Integer</code>: Length to consider to calculate metrics (default = 20).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L298-L307">source</a></section><section><div><pre><code class="nohighlight hljs">recallatL(y, yhat, L)</code></pre><p>Get mean recall@L per group as proposed by Wu, et al (2017).</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractVector</code>: Prediction score.</li><li><code>̂grouping::AbstractVector</code>: Group labels.</li><li><code>L::Integer</code>: Length to consider to calculate metrics (default = 20).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L330-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.precisionatL" href="#SimSpread.precisionatL"><code>SimSpread.precisionatL</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">precisionatL(y, yhat, L::Integer=20)</code></pre><p>Get precision@L as proposed by Wu, et al (2017).</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractVector</code>: Prediction score.</li><li><code>L::Integer</code>: Length to consider to calculate metrics (default = 20).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L360-L369">source</a></section><section><div><pre><code class="nohighlight hljs">precisionatL(y, yhat, grouping, L)</code></pre><p>Get mean precision@L per group as proposed by Wu, et al (2017).</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractVector</code>: Prediction score.</li><li><code>grouping::AbstractVector</code>: Group labels.</li><li><code>L::Integer</code>: Length to consider to calculate metrics (default = 20).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L387-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.BEDROC" href="#SimSpread.BEDROC"><code>SimSpread.BEDROC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">BEDROC(y::AbstractVector{Bool}, yhat::AbstractVector; rev::Bool=true, α::AbstractFloat=20.0)</code></pre><p>The Boltzmann Enhanced Descrimination of the Receiver Operator Characteristic (BEDROC) score is a modification of the Receiver Operator Characteristic (ROC) score that allows for a factor of <em>early recognition</em>.</p><p>Score takes a value in interval [0, 1] indicating degree to which the predictive model employed detects (early) the positive class.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractArray</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractArray</code>: Prediction scores.</li><li><code>rev::Bool</code>: True if high values of <span>$yhat$</span> correlates to positive class (default = true).</li><li><code>α::AbstractFloat</code>: Early recognition parameter (default = 20.0).</li></ul><p><strong>References</strong></p><ol><li>Truchon, J.-F., &amp; Bayly, C. I. (2007). Evaluating Virtual Screening Methods:  Good and</li></ol><p>Bad Metrics for the “Early Recognition” Problem. Journal of Chemical Information and Modeling, 47(2), 488–508. https://doi.org/10.1021/ci600426e</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L1-L21">source</a></section></article><h3 id="Binary-prediction-performance"><a class="docs-heading-anchor" href="#Binary-prediction-performance">Binary prediction performance</a><a id="Binary-prediction-performance-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-prediction-performance" title="Permalink"></a></h3><p>A common practice in predictive modelling is to assign a score or probability threshold for the predictions obtained from a model and manually select or cherry-pick predictions for validation. In order to evaluate the predictive performance under this paradigm, we implement a series of metrics that are meant for binary classification, that is, a link exists or not  based in a given threshold, from which statistical moments can be calculated to retrieve a  notion of predictive performance as a decision boundary changes.</p><article class="docstring"><header><a class="docstring-binding" id="SimSpread.f1score" href="#SimSpread.f1score"><code>SimSpread.f1score</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">f1score(tn::T, fp::T, fn::T, tp::T) where {T&lt;:Integer}</code></pre><p>The harmonic mean between precision and recall</p><p><strong>Arguments</strong></p><ul><li><code>tn::Integer</code> True negatives</li><li><code>fp::Integer</code> False postives</li><li><code>fn::Integer</code> False negatives</li><li><code>tp::Integer</code> True positives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L91-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.mcc" href="#SimSpread.mcc"><code>SimSpread.mcc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mcc(a::T, b::T, ϵ::AbstractFloat = 0.0001) where {T&lt;:Integer}</code></pre><p>Matthews correlation coefficient using calculus approximation for when FN+TN, FP+TN, TP+FN or TP+FP equals zero.</p><p><strong>Arguments</strong></p><ul><li><code>a::Integer</code> = Value of position <code>a</code> in confusion matrix</li><li><code>b::Integer</code> = Value of position <code>b</code> in confusion matrix</li><li><code>ϵ::AbstractFloat</code> = Approximation coefficient (default = floatmin(Float64))</li></ul><p><strong>Extended help</strong></p><p>The confusion matrix in a binary prediction is comprised of 4 distinct positions:</p><pre><code class="nohighlight hljs">                    | Predicted positive     Predicted negative
    ----------------+--------------------------------------------
    Actual positive |  True positives (TP)   False negatives (FN)
    Actual negative | False positives (FP)    True negatives (TN)</code></pre><p>In the case a row or column of the confusion matrix equals zero, MCC is undefined. Therefore, to correctly use MCC with this approximation, arguments <code>a</code> and <code>b</code> are defined as follows:</p><ul><li>If &quot;Predictive positive&quot; column is zero, <code>a</code> is TN and <code>b</code> is FN</li><li>If &quot;Predictive negative&quot; column is zero, <code>a</code> is TP and <code>b</code> is FP</li><li>If &quot;Actual positive&quot; row is zero, <code>a</code> is TN and <code>b</code> is FP</li><li>If &quot;Actual negative&quot; row is zero, <code>a</code> is TP and <code>b</code> is FN</li></ul><p><strong>Reference</strong></p><p>1.Chicco, D., Jurman, G. The advantages of the Matthews correlation coefficient (MCC) over F1 score and accuracy in binary classification evaluation. BMC Genomics 21, 6 (2020).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L116-L149">source</a></section><section><div><pre><code class="nohighlight hljs">mcc(tn::T, fp::T, fn::T, tp::T) where {T&lt;:Integer}</code></pre><p>Matthews correlation coefficient, a special case of the phi coeficient Performance metric used for overcoming the class imbalance issues</p><p><strong>Arguments</strong></p><ul><li><code>tn::Integer</code> True negatives</li><li><code>fp::Integer</code> False postives</li><li><code>fn::Integer</code> False negatives</li><li><code>tp::Integer</code> True positives</li></ul><p><strong>Reference</strong></p><p>1.Chicco, D., Jurman, G. The advantages of the Matthews correlation coefficient (MCC) over F1 score and accuracy in binary classification evaluation. BMC Genomics 21, 6 (2020).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L154-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.accuracy" href="#SimSpread.accuracy"><code>SimSpread.accuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">accuracy(tn::T, fp::T, fn::T, tp::T) where {T&lt;:Integer}</code></pre><p>The number of all correct predictions divided by the total predicitions</p><p><strong>Arguments</strong></p><ul><li><code>tn::Integer</code> True negatives</li><li><code>fp::Integer</code> False postives</li><li><code>fn::Integer</code> False negatives</li><li><code>tp::Integer</code> True positives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L203-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.balancedaccuracy" href="#SimSpread.balancedaccuracy"><code>SimSpread.balancedaccuracy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">balancedaccuracy(tn::T, fp::T, fn::T, tp::T) where {T&lt;:Integer}</code></pre><p>The arithmetic mean of sensitivity and specificity, its use case is when dealing with imbalanced data</p><p><strong>Arguments</strong></p><ul><li><code>tn::Integer</code> True negatives</li><li><code>fp::Integer</code> False postives</li><li><code>fn::Integer</code> False negatives</li><li><code>tp::Integer</code> True positives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L228-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.recall" href="#SimSpread.recall"><code>SimSpread.recall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">recall(tn::T, fp::T, fn::T, tp::T) where {T&lt;:Integer}</code></pre><p>The fraction of positive samples correctly predicted as postive</p><p><strong>Arguments</strong></p><ul><li><code>tn::Integer</code> True negatives</li><li><code>fp::Integer</code> False postives</li><li><code>fn::Integer</code> False negatives</li><li><code>tp::Integer</code> True positives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L251-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.precision" href="#SimSpread.precision"><code>SimSpread.precision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">precision(tn::T, fp::T, fn::T, tp::T) where {T&lt;:Integer}</code></pre><p>The fraction of positive predictions that are correct</p><p><strong>Arguments</strong></p><ul><li><code>tn::Integer</code> True negatives</li><li><code>fp::Integer</code> False postives</li><li><code>fn::Integer</code> False negatives</li><li><code>tp::Integer</code> True positives</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L275-L284">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.meanperformance" href="#SimSpread.meanperformance"><code>SimSpread.meanperformance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meanperformance(confusion::AbstractVector{ROCNums{Int64}}, metric::Function)</code></pre><p>Get mean performance of a given metric over a set of confusion matrices.</p><p><strong>Arguments</strong></p><ul><li><code>confusion::AbstractVector{ROCNums{Int64}}</code>: Confusion matrices</li><li><code>̂metric::Function</code>: Performance metric function to use in evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L450-L458">source</a></section><section><div><pre><code class="nohighlight hljs">meanperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)</code></pre><p>Get mean performance of a given metric over a pair of label-prediction vectors.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractVector</code>: Prediction score.</li><li><code>̂metric::Function</code>: Performance metric function to use in evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L471-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.meanstdperformance" href="#SimSpread.meanstdperformance"><code>SimSpread.meanstdperformance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">meanstdperformance(confusion::AbstractVector{ROCNums{Real}}, metric::Function)</code></pre><p>Get mean and standard deviation performance of a given metric over a set of confusion matrices.</p><p><strong>Arguments</strong></p><ul><li><code>confusion::AbstractVector{ROCNums{Real}}</code>: Confusion matrix object from MLBase</li><li><code>̂metric::Function</code>: Performance metric function to use in evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L491-L499">source</a></section><section><div><pre><code class="nohighlight hljs">meanstdperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)</code></pre><p>Get mean and standard deviation performance of a given metric over a pair of label-prediction vectors.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractVector</code>: Prediction scores.</li><li><code>̂metric::Function</code>: Performance metric function to use in evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L512-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.maxperformance" href="#SimSpread.maxperformance"><code>SimSpread.maxperformance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>maxperformance(confusion::AbstractVector{ROCNums{Real}}, metric::Function)</p><p>Get maximum performance of a given metric over a set of confusion matrices.</p><p><strong>Arguments</strong></p><ul><li><code>confusion::AbstractVector{ROCNums{Real}}</code>: Confusion matrices.</li><li><code>̂metric::Function</code>: Performance metric function to use in evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L416-L424">source</a></section><section><div><pre><code class="nohighlight hljs">maxperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)</code></pre><p>Get maximum performance of a given metric over a pair of label-prediction vectors.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector{Bool}</code>: Binary class labels. 1 for positive class, 0 otherwise.</li><li><code>̂yhat::AbstractVector{Float64}</code>: Prediction score.</li><li><code>̂metric::Function</code>: Performance metric function to use in evaluation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L430-L439">source</a></section></article><h3 id="Other-metrics"><a class="docs-heading-anchor" href="#Other-metrics">Other metrics</a><a id="Other-metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Other-metrics" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="SimSpread.validity_ratio" href="#SimSpread.validity_ratio"><code>SimSpread.validity_ratio</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">validity_ratio(yhat::AbstractVector)</code></pre><p>Ratio of valid predictions (score &gt; 0) and all predictions. Allows to check if predictive performance is given for all predictions or a subset of the predictions.</p><p><strong>Arguments</strong></p><ul><li><code>yhat::AbstractVector</code> : Prediction scores.</li></ul><p><strong>Extended help</strong></p><p>A limitation of SimSpread is that it is impossible to generate predictions for query nodes whose similarity to every source of the first network layer is below the similarity threshold α. In this case, the length of the feature vector is zero, resource spreading is not possible, and the predicted value is zero for all targets, therefore we need guardrails to correctly assess  performance as a function of the threshold α.</p><p>This characteristic of SimSpread can be seen as an intrinsic notion of its application domain. No target predictions are generated for query nodes outside SimSpread’s application domain instead of returning likely meaningless targets.</p><p><strong>References</strong></p><ol><li>Vigil-Vásquez &amp; Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/performance.jl#L533-L557">source</a></section></article><h2 id="Miscellaneous-utilities"><a class="docs-heading-anchor" href="#Miscellaneous-utilities">Miscellaneous utilities</a><a id="Miscellaneous-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SimSpread.read_namedmatrix" href="#SimSpread.read_namedmatrix"><code>SimSpread.read_namedmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_namedmatrix(filepath::String, valuetype::Type = FLoat64filepath::String, valuetype::Type)</code></pre><p>Load a matrix with named indices as a NamedArray.</p><p><strong>Arguments</strong></p><ul><li><code>filepath::String</code> : File path of matrix to load</li><li><code>delimiter::Char</code> : Delimiter character between values in matrix (default = &#39; &#39;)</li><li><code>valuetype::Type</code> : Type of values contained in matrix (default = Float64)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/utils.jl#L40-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.k" href="#SimSpread.k"><code>SimSpread.k</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">k(G::AbstractMatrix)</code></pre><p>Get node degrees from adjacency matrix</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractMatrix</code> : Matrix to parse</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/graphs.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SimSpread.getyamanishi" href="#SimSpread.getyamanishi"><code>SimSpread.getyamanishi</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getyamanishi(db)</code></pre><p>Get a tuple of matrices corresponding to the drug-target adjacency matrix and drug-drug similarity matrix for a given Yamanishi (2008) dataset.</p><p><strong>Arguments</strong></p><ul><li><code>db</code>: Dataset ID (any of the following: &quot;nr&quot;, &quot;ic&quot;, &quot;gpcr&quot; or &quot;e&quot;)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; dt, dd = getyamanishi(&quot;nr&quot;);

julia&gt; dt[1:5, 1:5]
5×5 Named Matrix{Float64}
 A ╲ B │  hsa190  hsa2099  hsa2100  hsa2101  hsa2103
───────┼────────────────────────────────────────────
D00040 │     0.0      0.0      0.0      0.0      0.0
D00066 │     0.0      1.0      0.0      0.0      0.0
D00067 │     0.0      1.0      0.0      0.0      0.0
D00075 │     0.0      0.0      0.0      0.0      0.0
D00088 │     0.0      0.0      0.0      0.0      0.0

julia&gt; dd[1:5, 1:5]
5×5 Named Matrix{Float64}
 A ╲ B │   D00040    D00066    D00067    D00075    D00088
───────┼─────────────────────────────────────────────────
D00040 │      1.0  0.545455  0.297297   0.53125  0.459459
D00066 │ 0.545455       1.0  0.387097  0.833333  0.689655
D00067 │ 0.297297  0.387097       1.0  0.464286  0.352941
D00075 │  0.53125  0.833333  0.464286       1.0  0.678571
D00088 │ 0.459459  0.689655  0.352941  0.678571       1.0</code></pre><p><strong>Extended help</strong></p><p>The provided Yamanishi (2008) [1] datasets (ID) are:</p><ul><li>&#39;Nuclear Receptor&#39; (nr)</li><li>&#39;Ion Channels&#39; (ic)</li><li>&#39;GPCR&#39; (gpcr)</li><li>&#39;Enzyme&#39; (e)</li></ul><p>This function returns 2 distinct adjacency matrices:</p><ul><li>Binary drug-target interaction matrix, obtained from biological annotations</li><li>Continuous drug-drug similarity matrix, obtained from SIMCOMP</li></ul><p><strong>References</strong></p><ol><li>Yamanishi, Y., Araki, M., Gutteridge, A., Honda, W., &amp; Kanehisa, M. (2008). Prediction of drug–target interaction networks from the integration of chemical and genomic spaces. Bioinformatics, 24(13), i232–i240. https://doi.org/10.1093/bioinformatics/btn162</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvigilv/SimSpread.jl/blob/35debd8789018c63c14f85b608d25fd31bcc194a/src/examples.jl#L13-L64">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/fishers-flowers/">« Fisher&#39;s flowers</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Wednesday 16 August 2023 18:58">Wednesday 16 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
