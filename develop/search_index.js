var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = SimSpread","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Core","page":"API","title":"Core","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"spread\ncutoff\ncutoff!\nfeaturize\nfeaturize!\nconstruct\npredict\nsave","category":"page"},{"location":"api/#SimSpread.spread","page":"API","title":"SimSpread.spread","text":"spread(G::AbstractMatrix{Float64})\n\nCalculate the transfer matrix for the adyacency matrix of the trilayered feature-source-target network.\n\nArguments\n\nG::AbstractMatrix{Float64}: Trilayered feature-source-target network adjacency matrix.\n\nExtended help\n\nPotential interactions between nodes in a graph can be identified by using resource diffusion processes in the feature-source-target network, namely aforementioned graph G. For each node nᵢ in the network, it has initial resources located in both its neighboring nodes and its features. Initially, each feature and each neighboring node of nᵢ equally spread their resources to neighboring nodes. Subsequently, each of those nodes equally spreads its resources to neighbor nodes. Thus, nᵢ will obtain final resources located in several neighboring nodes, suggesting that nᵢ may have potential interactions with these nodes.\n\nReferences\n\nWu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.cutoff","page":"API","title":"SimSpread.cutoff","text":"cutoff(x::T, α::T, weighted::Bool=false) where {T<:AbstractFloat}\n\nTransform x based in SimSpread's similarity cutoff function.\n\nArguments\n\nx::AbstractFloat : Value to transform\nα::AbstractFloat : Similarity cutoff\nweighted::Bool : Apply weighting function to outcome (default = false)\n\n\n\n\n\ncutoff(M::AbstractVecOrMat{T}, α::T, weighted::Bool=false) where {T<:AbstractFloat}\n\nTransform the vector or matrix X based in SimSpread's similarity cutoff function.\n\nArguments\n\nX::AbstractVecOrMat{AbstractFloat} : Matrix or Vector to transform\nα::AbstractFloat : Similarity cutoff\nweighted::Bool : Apply weighting function to outcome (default = false)\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.cutoff!","page":"API","title":"SimSpread.cutoff!","text":"cutoff!(x::T, α::T, weighted::Bool=false) where {T<:AbstractFloat}\n\nTransform, in place, x based in SimSpread's similarity cutoff function.\n\nArguments\n\nx::AbstractFloat : Value to transform\nα::AbstractFloat : Similarity cutoff\nweighted::Bool : Apply weighting function to outcome (default = false)\n\n\n\n\n\ncutoff!(X::AbstractVecOrMat{T}, α::T, weighted::Bool=false) where {T<:AbstractFloat}\n\nTransform, in place, the vector or matrix X based in SimSpread's similarity cutoff function.\n\nArguments\n\nX::AbstractVecOrMat{AbstractFloat} : Matrix or Vector to transform\nα::AbstractFloat : Similarity threshold\nweighted::Bool : Apply weighting function to outcome (default = false)\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.featurize","page":"API","title":"SimSpread.featurize","text":"featurize(X::NamedArray, α::AbstractFloat, weighted::Bool=false)\n\nTransform the feature matrix X into a SimSpread feature matrix.\n\nArguments\n\nX::NamedArray: Continuous feature matrix\nα::AbstractFloat: Featurization cutoff\nweighted::Bool : Apply weighting function to outcome (default = false)\n\nReferences\n\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.featurize!","page":"API","title":"SimSpread.featurize!","text":"featurize!(X::NamedArray, α::AbstractFloat, weighted::Bool=false)\n\nTransform, in place, the feature matrix X into a SimSpread feature matrix.\n\nArguments\n\nX::NamedArray : Continuous feature matrix\nα::AbstractFloat : Featurization cutoff\nweighted::Bool : Apply weighting function to outcome (default = false)\n\nReferences\n\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.construct","page":"API","title":"SimSpread.construct","text":"construct(y::NamedMatrix, X::NamedMatrix, queries::AbstractVector)\n\nConstruct the query-feature-source-target network for de novo network-based inference prediction and return adjacency matrix.\n\nArguments\n\ny::NamedMatrix: Source-target bipartite network adjacency matrix\nX::NamedMatrix: Source-feature bipartite adjacency matrix\nqueries::AbstractVector: Source nodes to use as query\n\nExtended help\n\nThis implementation is intended for k-fold or leave-one-out cross-validation.\n\n\n\n\n\nconstruct(ys::T, Xs::T) where {T<:Tuple{NamedMatrix,NamedMatrix}}\n\nConstruct the query-feature-source-target network for de novo network-based inference prediction and return adjacency matrix.\n\nArguments\n\ndts::Tuple{NamedMatrix,NamedMatrix} : Source-target bipartite graph adjacency matrices\ndfs::Tuple{NamedMatrix,NamedMatrix} : Source-feature bipartite graph adjacency matrices\n\nExtended help\n\nThis implementations is intended for time-split cross-validation or manual construction of query network.\n\n\n\n\n\nconstruct(ytrain::T, ytest::T, Xtrain::T, Xtest::T) where {T<:NamedMatrix}\n\nConstruct the query-feature-source-target network for de novo network-based inference prediction and return adjacency matrix.\n\nArguments\n\nytrain::NamedMatrix : Training source-target bipartite graph adjacency matrix\nytest::NamedMatrix : Test source-target bipartite graph adjacency matrix\nXtrain::NamedMatrix : Training source-feature bipartite graph adjacency matrix\nXtest::NamedMatrix : Test source-feature bipartite graph adjacency matrix\n\nExtended help\n\nThis implementations is intended for time-split cross-validation or manual construction of query network.\n\n\n\n\n\nconstruct(y::NamedMatrix, X::NamedMatrix)\n\nConstruct the feature-source-target network for network-based inference prediction and return adjacency matrix.\n\nArguments\n\ny::NamedMatrix : Source-target bipartite graph adjacency matrix\nX::NamedMatrix : Source-feature bipartite graph adjacency matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.predict","page":"API","title":"SimSpread.predict","text":"predict(I::Tuple{T,T}, ytest::T; GPU::Bool=false) where {T<:NamedMatrix}\n\nPredict interactions between query and target nodes using de novo network-based inference model proposed by Wu, et al (2016).\n\nArguments\n\nI::Tuple{NamedMatrix,NamedMatrix}: Feature-source-target trilayered adjacency matrices\nytest::NamedMatrix: Query-target bipartite adjacency matrix\nGPU::Bool: Use GPU acceleration for calculation (default = false)\n\nReferences\n\nWu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\npredict(A::T, ytrain::T; GPU::Bool=false) where {T<:NamedMatrix}\n\nPredict interactions between query and target nodes using de novo network-based inference model proposed by Wu, et al (2016).\n\nArguments\n\nA::NamedMatrix: Feature-source-target trilayered adjacency matrix\nytrain::NamedMatrix: Source-target bipartite adjacency matrix\nGPU::Bool: Use GPU acceleration for calculation (default = false)\n\nReferences\n\nWu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.save","page":"API","title":"SimSpread.save","text":"save(filepath::String, yhat::NamedMatrix, y::NamedMatrix; delimiter::Char='\t')\n\nStore predictions as a table in the given file path.\n\nArguments\n\nfilepath::String: Output file path\nyhat::NamedArray: Predicted source-target bipartite adjacency matrix\ny::NamedArray: Ground-truth source-target bipartite adjacency matrix\ndelimiter::Char: Delimiter used to write table (default = '\\t')\n\nExtended help\n\nTable format is:\n\nfold, source, target, score, label\n\n\n\n\n\nsave(filepath::String, fidx::Int64, yhat::NamedMatrix, y::NamedMatrix; delimiter::Char='\t')\n\nStore cross-valudation predictions as a table in the given file path.\n\nArguments\n\nfilepath::String: Output file path\nfidx::Int64: Numeric fold ID\nyhat::NamedArray: Predicted source-target bipartite adjacency matrix\ny::NamedArray: Ground-truth source-target bipartite adjacency matrix\ndelimiter::Char: Delimiter used to write table (default = '\\t')\n\nExtended help\n\nTable format is:\n\nfold, source, target, score, label\n\n\n\n\n\n","category":"function"},{"location":"api/#Cross-validation","page":"API","title":"Cross-validation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"split\nclean!","category":"page"},{"location":"api/#Base.split","page":"API","title":"Base.split","text":"Base.split(y::NamedArray, k::Int64; seed::Int64=1)\n\nSplit source nodes in y into k groups for cross-validation.\n\nArguments\n\ny::AbstractMatrix: Drug-Target rectangular adjacency matrix.\nk::Int64: Number of groups to use in data splitting.\nseed::Int64: Seed used for data splitting.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.clean!","page":"API","title":"SimSpread.clean!","text":"clean!(yhat::NamedArray, A::NamedArray, y::NamedArray)\n\nFlag, in place, erroneous prediction from cross-validation splitting.\n\nArguments\n\nyhat::NamedArray: Predicted source-target bipartite adjacency matrix\nA::NamedArray: Initial resource source-target resources adjacency matrix\ny::NamedArray: Ground-truth source-target bipartite adjacency matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#Performance-assessment","page":"API","title":"Performance assessment","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Several evaluation metrics are implemented in the package, which can be that can be classified into three groups: (i) overall performance, (ii) early recognition, and (iii) binary prediction  performance.","category":"page"},{"location":"api/#Overall-performance","page":"API","title":"Overall performance","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This metrics represent classical evaluation metrics that make use of the complete list of prediction to assess predictive performance.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AuPRC\nAuROC","category":"page"},{"location":"api/#SimSpread.AuPRC","page":"API","title":"SimSpread.AuPRC","text":"AuPRC(y::AbstractVector{Bool}, yhat::AbstractVector)\n\nArea under the Precision-Recall curve using the trapezoidal rule.\n\nArguments\n\ny::AbstractArray: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractArray: Prediction scores.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.AuROC","page":"API","title":"SimSpread.AuROC","text":"AuROC(y::AbstractVector{Bool}, yhat::AbstractVector)\n\nArea under the Receiver Operator Characteristic curve using the trapezoidal rule.\n\nArguments\n\ny::AbstractArray: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractArray: Prediction scores.\n\n\n\n\n\n","category":"function"},{"location":"api/#Early-recognition-performance","page":"API","title":"Early recognition performance","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Due to the roots of SimSpread (target prediction in drug discovery), we incude evaluation metrics that aim to assess predictive performance of the best predictions obtained from a model.","category":"page"},{"location":"api/","page":"API","title":"API","text":"In virtual screening, only the best predictions obtained from a model are selected for  posterior experimental validation. Therefore, understanding the predictive performance of a model for these predictions is essential to (1) make accurate predictions that will translate to biological activity and (2) understand the limitations of the model. The metrics discussed here can be evaluated at a given cut-off rank, considering only the topmost results returned by the predictive method, hence informing of the predictive performance of the model for only the best predictions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"recallatL\nprecisionatL\nBEDROC","category":"page"},{"location":"api/#SimSpread.recallatL","page":"API","title":"SimSpread.recallatL","text":"recallatL(y, yhat, L)\n\nGet recall@L as proposed by Wu, et al (2017).\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\nL::Integer: Length to consider to calculate metrics (default = 20).\n\n\n\n\n\nrecallatL(y, yhat, L)\n\nGet mean recall@L per group as proposed by Wu, et al (2017).\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\n̂grouping::AbstractVector: Group labels.\nL::Integer: Length to consider to calculate metrics (default = 20).\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.precisionatL","page":"API","title":"SimSpread.precisionatL","text":"precisionatL(y, yhat, L::Integer=20)\n\nGet precision@L as proposed by Wu, et al (2017).\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\nL::Integer: Length to consider to calculate metrics (default = 20).\n\n\n\n\n\nprecisionatL(y, yhat, grouping, L)\n\nGet mean precision@L per group as proposed by Wu, et al (2017).\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\ngrouping::AbstractVector: Group labels.\nL::Integer: Length to consider to calculate metrics (default = 20).\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.BEDROC","page":"API","title":"SimSpread.BEDROC","text":"BEDROC(y::AbstractVector{Bool}, yhat::AbstractVector; rev::Bool=true, α::AbstractFloat=20.0)\n\nThe Boltzmann Enhanced Descrimination of the Receiver Operator Characteristic (BEDROC) score is a modification of the Receiver Operator Characteristic (ROC) score that allows for a factor of early recognition.\n\nScore takes a value in interval [0, 1] indicating degree to which the predictive model employed detects (early) the positive class.\n\nArguments\n\ny::AbstractArray: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractArray: Prediction scores.\nrev::Bool: True if high values of yhat correlates to positive class (default = true).\nα::AbstractFloat: Early recognition parameter (default = 20.0).\n\nReferences\n\nTruchon, J.-F., & Bayly, C. I. (2007). Evaluating Virtual Screening Methods:  Good and\n\nBad Metrics for the “Early Recognition” Problem. Journal of Chemical Information and Modeling, 47(2), 488–508. https://doi.org/10.1021/ci600426e\n\n\n\n\n\n","category":"function"},{"location":"api/#Binary-prediction-performance","page":"API","title":"Binary prediction performance","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A common practice in predictive modelling is to assign a score or probability threshold for the predictions obtained from a model and manually select or cherry-pick predictions for validation. In order to evaluate the predictive performance under this paradigm, we implement a series of metrics that are meant for binary classification, that is, a link exists or not  based in a given threshold, from which statistical moments can be calculated to retrieve a  notion of predictive performance as a decision boundary changes.","category":"page"},{"location":"api/","page":"API","title":"API","text":"f1score\nmcc\naccuracy\nbalancedaccuracy\nrecall\nprecision\nmeanperformance\nmeanstdperformance\nmaxperformance","category":"page"},{"location":"api/#SimSpread.f1score","page":"API","title":"SimSpread.f1score","text":"f1score(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe harmonic mean between precision and recall\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.mcc","page":"API","title":"SimSpread.mcc","text":"mcc(a::T, b::T, ϵ::AbstractFloat = 0.0001) where {T<:Integer}\n\nMatthews correlation coefficient using calculus approximation for when FN+TN, FP+TN, TP+FN or TP+FP equals zero.\n\nArguments\n\na::Integer = Value of position a in confusion matrix\nb::Integer = Value of position b in confusion matrix\nϵ::AbstractFloat = Approximation coefficient (default = floatmin(Float64))\n\nExtended help\n\nThe confusion matrix in a binary prediction is comprised of 4 distinct positions:\n\n                    | Predicted positive     Predicted negative\n    ----------------+--------------------------------------------\n    Actual positive |  True positives (TP)   False negatives (FN)\n    Actual negative | False positives (FP)    True negatives (TN)\n\nIn the case a row or column of the confusion matrix equals zero, MCC is undefined. Therefore, to correctly use MCC with this approximation, arguments a and b are defined as follows:\n\nIf \"Predictive positive\" column is zero, a is TN and b is FN\nIf \"Predictive negative\" column is zero, a is TP and b is FP\nIf \"Actual positive\" row is zero, a is TN and b is FP\nIf \"Actual negative\" row is zero, a is TP and b is FN\n\nReference\n\n1.Chicco, D., Jurman, G. The advantages of the Matthews correlation coefficient (MCC) over F1 score and accuracy in binary classification evaluation. BMC Genomics 21, 6 (2020).\n\n\n\n\n\nmcc(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nMatthews correlation coefficient, a special case of the phi coeficient Performance metric used for overcoming the class imbalance issues\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\nReference\n\n1.Chicco, D., Jurman, G. The advantages of the Matthews correlation coefficient (MCC) over F1 score and accuracy in binary classification evaluation. BMC Genomics 21, 6 (2020).\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.accuracy","page":"API","title":"SimSpread.accuracy","text":"accuracy(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe number of all correct predictions divided by the total predicitions\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.balancedaccuracy","page":"API","title":"SimSpread.balancedaccuracy","text":"balancedaccuracy(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe arithmetic mean of sensitivity and specificity, its use case is when dealing with imbalanced data\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.recall","page":"API","title":"SimSpread.recall","text":"recall(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe fraction of positive samples correctly predicted as postive\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.precision","page":"API","title":"SimSpread.precision","text":"precision(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe fraction of positive predictions that are correct\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.meanperformance","page":"API","title":"SimSpread.meanperformance","text":"meanperformance(confusion::AbstractVector{ROCNums{Int64}}, metric::Function)\n\nGet mean performance of a given metric over a set of confusion matrices.\n\nArguments\n\nconfusion::AbstractVector{ROCNums{Int64}}: Confusion matrices\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\nmeanperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)\n\nGet mean performance of a given metric over a pair of label-prediction vectors.\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.meanstdperformance","page":"API","title":"SimSpread.meanstdperformance","text":"meanstdperformance(confusion::AbstractVector{ROCNums{Real}}, metric::Function)\n\nGet mean and standard deviation performance of a given metric over a set of confusion matrices.\n\nArguments\n\nconfusion::AbstractVector{ROCNums{Real}}: Confusion matrix object from MLBase\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\nmeanstdperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)\n\nGet mean and standard deviation performance of a given metric over a pair of label-prediction vectors.\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction scores.\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.maxperformance","page":"API","title":"SimSpread.maxperformance","text":"maxperformance(confusion::AbstractVector{ROCNums{Real}}, metric::Function)\n\nGet maximum performance of a given metric over a set of confusion matrices.\n\nArguments\n\nconfusion::AbstractVector{ROCNums{Real}}: Confusion matrices.\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\nmaxperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)\n\nGet maximum performance of a given metric over a pair of label-prediction vectors.\n\nArguments\n\ny::AbstractVector{Bool}: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector{Float64}: Prediction score.\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Other-metrics","page":"API","title":"Other metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"validity_ratio","category":"page"},{"location":"api/#SimSpread.validity_ratio","page":"API","title":"SimSpread.validity_ratio","text":"validity_ratio(yhat::AbstractVector)\n\nRatio of valid predictions (score > 0) and all predictions. Allows to check if predictive performance is given for all predictions or a subset of the predictions.\n\nArguments\n\nyhat::AbstractVector : Prediction scores.\n\nExtended help\n\nA limitation of SimSpread is that it is impossible to generate predictions for query nodes whose similarity to every source of the first network layer is below the similarity threshold α. In this case, the length of the feature vector is zero, resource spreading is not possible, and the predicted value is zero for all targets, therefore we need guardrails to correctly assess  performance as a function of the threshold α.\n\nThis characteristic of SimSpread can be seen as an intrinsic notion of its application domain. No target predictions are generated for query nodes outside SimSpread’s application domain instead of returning likely meaningless targets.\n\nReferences\n\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#Miscellaneous-utilities","page":"API","title":"Miscellaneous utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"read_namedmatrix\nk","category":"page"},{"location":"api/#SimSpread.read_namedmatrix","page":"API","title":"SimSpread.read_namedmatrix","text":"read_namedmatrix(filepath::String, valuetype::Type = FLoat64filepath::String, valuetype::Type)\n\nLoad a matrix with named indices as a NamedArray.\n\nArguments\n\nfilepath::String : File path of matrix to load\ndelimiter::Char : Delimiter character between values in matrix (default = ' ')\nvaluetype::Type : Type of values contained in matrix (default = Float64)\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.k","page":"API","title":"SimSpread.k","text":"k(G::AbstractMatrix)\n\nGet node degrees from adjacency matrix\n\nArguments\n\nM::AbstractMatrix : Matrix to parse\n\n\n\n\n\n","category":"function"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"CurrentModule = SimSpread","category":"page"},{"location":"#SimSpread.jl","page":"Welcome to SimSpread.jl","title":"SimSpread.jl","text":"","category":"section"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"A package implementing the SimSpread formalism for link prediction.","category":"page"},{"location":"#Installation","page":"Welcome to SimSpread.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"SimSpread.jl can be installed typing","category":"page"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"Pkg.add(url=\"https://github.com/cvigilv/SimSpread.jl.git\", rev=\"develop\")","category":"page"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"in the Julia REPL.","category":"page"},{"location":"#Package-Features","page":"Welcome to SimSpread.jl","title":"Package Features","text":"","category":"section"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"Core implementation of SimSpread preditive algorithm\nHelper functions for preparation and construction of query graphs\nHelper function for cross-validation\nPerformance assessment metrics","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"EditURL = \"https://github.com/cvigilv/SimSpread.jl/blob/main/docs/src/tutorial/getting-started.jl\"","category":"page"},{"location":"tutorial/getting-started/#Getting-started-with-SimSpread.jl","page":"Getting started","title":"Getting started with SimSpread.jl","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"TODO: Small introdution to SimSpread, its origins and use cases","category":"page"},{"location":"tutorial/getting-started/#Preparing-our-environment","page":"Getting started","title":"Preparing our environment","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"For this short and concise tutorial, we will use as an example the classic \"Iris\" dataset proposed by R.A. Fisher, in a classification problem. Let's go ahead and load the dataset:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"using MLDatasets, DataFrames\n\niris = Iris().dataframe\nfirst(iris, 5)","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Since we will use SimSpread as a classification algorithm for a single-class problem, we need to convert the class column into 3 distinct columns corresponding to each of the classes in the dataset, i.e., one-hot encode the class column. For this, we can use the following transformation","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"transform!(\n    iris,\n    :class => ByRow(c -> c .== \"Iris-setosa\") => \"Is Iris-setosa?\",\n    :class => ByRow(c -> c .== \"Iris-versicolor\") => \"Is Iris-versicolor?\",\n    :class => ByRow(c -> c .== \"Iris-virginica\") => \"Is Iris-virginica?\",\n)\nfirst(iris, 5)","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"and obtain 3 columns that encode the class for each plant.","category":"page"},{"location":"tutorial/getting-started/#Data-splitting","page":"Getting started","title":"Data splitting","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Next, we will train a model using SimSpread to predict the classes for a subset of plants in the Iris dataset. For this, we will split our dataset in 2 groups: training set, which will correspond to 80% of the data, and testing set, which will correspond to the remaining 20%.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"For this, will first shuffle the plants and extract the first 20% of the dataset with the following code:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"using Random\n\nRandom.seed!(1)\nN = nrow(iris)\nperm = randperm(N)\n\ntrain_idx = last(perm, Int(0.8 * N))\ntest_idx = first(perm, Int(0.2 * N))\n\nXtrain = iris[train_idx, [\"sepallength\", \"sepalwidth\", \"petallength\", \"petalwidth\"]]\nXtest  = iris[test_idx,  [\"sepallength\", \"sepalwidth\", \"petallength\", \"petalwidth\"]]\nytrain = iris[train_idx, [\"Is Iris-setosa?\", \"Is Iris-versicolor?\", \"Is Iris-virginica?\"]]\nytest  = iris[test_idx,  [\"Is Iris-setosa?\", \"Is Iris-versicolor?\", \"Is Iris-virginica?\"]];\nnothing #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"The first 5 entries of the training set have the following features:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"first(Xtrain, 5)","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"And the following one-hot encoded classes:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"first(ytrain, 5)","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"The first 5 entries of the test set have the following features:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"first(Xtest, 5)","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"And the following one-hot encoded classes:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"first(ytest, 5)","category":"page"},{"location":"tutorial/getting-started/#Meta-description-preparation","page":"Getting started","title":"Meta-description preparation","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"SimSpread works using a meta-description based out of similarity between objects (in this tutorial, plants). For this, we first need to compute how similar plants in the training set are (all-vs-all comparison) and how similar are the plants in the testing set to the training set.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Once that is computed, we construct the meta-description using a similarity threshold that creates a new matrix that encodes the question \"Is plant A similar to plant B?\".","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Weight the transformed similarity matrix using a binary, s^prime_ij = s_ij  0, or continuous, s^prime_ij = (s_ij  0) times s_ij, transformation.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"The resulting matrix corresponds to the new feature matrix, corresponding to a meta -description of the source nodes based in its similarity to the other nodes and itself.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"For the example, we will use the Jaccard index as our similarity measure, since its bound between 0 and 1:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"using Distances, NamedArrays\n\n\nDtrain = 1 .- pairwise(Jaccard(), Matrix(Xtrain), dims=1)\nDtest  = 1 .- pairwise(Jaccard(), Matrix(Xtest), Matrix(Xtrain), dims=1)\n\nDtrain = NamedArray(Dtrain, ([\"E$i\" for i in train_idx], [\"E$i\" for i in train_idx] ))\nDtest  = NamedArray(Dtest, ([\"E$i\" for i in test_idx], [\"E$i\" for i in train_idx] ));\nnothing #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"and will use a cutoff of J(xy) = 09, since this generally represent comparison between two highly similar entities:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"using SimSpread\n\nclass_names = [\"Is Iris-setosa?\", \"Is Iris-versicolor?\", \"Is Iris-virginica?\"]\n\nα = 0.9\nXtrain′ = featurize(Dtrain, α, true)\nXtest′  = featurize(Dtest, α, true)\nytrain′ = NamedArray(Matrix{Float64}(ytrain), ([\"E$i\" for i in train_idx], class_names))\nytest′  = NamedArray(Matrix{Float64}(ytest), ([\"E$i\" for i in test_idx], class_names));\nnothing #hide","category":"page"},{"location":"tutorial/getting-started/#Predicting-labels-with-SimSpread","page":"Getting started","title":"Predicting labels with SimSpread","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Now that we have all the information necessary for SimSpread, we can construct the query graph that is used to predict links using network-based-inference resource allocation algorithm.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"In first place, we need to construct the query network for label prediction:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"G = construct(ytrain′, ytest′, Xtrain′, Xtest′)","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"From this, we can predict the labels as follows:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"ŷtrain = predict(G, ytrain′)\nŷtest = predict(G, ytest′)\n\nŷtest[1:3, :]","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"As we can see, we predict the probability for each class of flower possible. To evaluate the predictive performance as a multiclass problem, we will assign the label with the highest score as the predicted label.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"In the example above, the predicted labels for each row in the matrix would be \"Iris-virginica\" (C3), \"Iris-setosa\" (C1) & \"Iris-setosa\" (C1).","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"To convert the problem from single-class to multi-class, we do the following:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"class_mapper = [\"Iris-setosa\", \"Iris-versicolor\", \"Iris-virginica\"]\n\nŷ = hcat(\n    vcat(test_idx, train_idx),\n    vcat(\n        [class_mapper[cidx] for (_, cidx) in Tuple.(argmax(ŷtest, dims=2))],\n        [class_mapper[cidx] for (_, cidx) in Tuple.(argmax(ŷtrain, dims=2))]\n    )\n)\n\nfirst(ŷ[:, 2], 3)","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Great! Our predicted labels match what we expected. Now let's assess how good is SimSpread in predicting the classes for the iris dataset.","category":"page"},{"location":"tutorial/getting-started/#Assesing-the-predictive-performance-of-the-proposed-model","page":"Getting started","title":"Assesing the predictive performance of the proposed model","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"In order to have an idea of the predictive performance of the model we constructed, we will use two common metrics in multi-class prediction problems to evaluate the predictions for both the training and testing sets:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Accuracy, that indicates how close a given set of predictions are to their true value, and\nError rate, that indicates the inverse of accuracy.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Let's start with accuracy:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"using AlgebraOfGraphics, CairoMakie\n\ndf = (\n    train=[Bool(i ∈ train_idx) for i in 1:N],\n    y=iris[!, \"class\"],\n    yhat=ŷ[sortperm(ŷ[:, 1]), 2]\n)\n\nplt = data(df)\nplt *= expectation()\nplt *= mapping(\n    :y => \"Class\",\n    (:y, :yhat) => isequal => \"Accuracy\"\n)\nplt *= mapping(\n    dodge=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\",\n    color=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\"\n)\n\ndraw(plt; axis=(width=400, height=225))","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"As we can see, our proposed SimSpread model achieves high accuracy for both training and testing sets. Let's see the error rates for the same grouping:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"plt = data(df)\nplt *= expectation()\nplt *= mapping(\n    :y => \"Class\",\n    (:y, :yhat) => !isequal => \"Error rate\"\n)\nplt *= mapping(\n    dodge=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\",\n    color=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\"\n)\n\ndraw(plt; axis=(width=400, height=225))","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Here we also see goo performance, achieving low error rate for all the classes in both the training and testing sets. We also can appreciate that the the testing set present a higher mean error rate than the training set.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Let's visualize where the predicted classes fall in our training and testing sets. First, lets see our ground truth:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"df = (\n    sepallength=iris[!, \"sepallength\"],\n    petallength=iris[!, \"petallength\"],\n    y=iris[!, \"class\"],\n)\nplt = data(df)\nplt *= mapping(\n    :sepallength => \"Sepal Length (cm)\",\n    :petallength => \"Petal Length (cm)\",\n    color=:y => \"Class\"\n)\ndraw(plt; axis=(width=300, height=300))","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"We can clearly see that setosa plants are completely separated from the rest of the plants in the dataset. Versicolor and virginica present some overlap, which might respond to what we have see in the predictive performance.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Let's visualize the prediction over this scatter plot to map where are the incorrect predictions:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"df = (\n    sepallength=iris[!, \"sepallength\"],\n    petallength=iris[!, \"petallength\"],\n    train=[Bool(i ∈ train_idx) for i in 1:N],\n    y=iris[!, \"class\"],\n    yhat=ŷ[sortperm(ŷ[:, 1]), 2]\n)\n\nplt = data(df)\nplt *= mapping(\n    :sepallength => \"Sepal Length (cm)\",\n    :petallength => \"Petal Length (cm)\",\n    row=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\",\n    col=:y => \"Class\",\n    color=:yhat => \"Predicted class\"\n)\n\ndraw(plt; axis=(width=225, height=225))","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"}]
}
