var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"CurrentModule = SimSpread","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Core","page":"API","title":"Core","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"spread\ncutoff\ncutoff!\nfeaturize\nfeaturize!\nconstruct\npredict\nsave","category":"page"},{"location":"api/#SimSpread.spread","page":"API","title":"SimSpread.spread","text":"spread(G::AbstractMatrix{Float64})\n\nCalculate the transfer matrix for the adyacency matrix of the trilayered feature-source-target network.\n\nArguments\n\nG::AbstractMatrix{Float64}: Trilayered feature-source-target network adjacency matrix.\n\nExtended help\n\nPotential interactions between nodes in a graph can be identified by using resource diffusion processes in the feature-source-target network, namely aforementioned graph G. For each node nᵢ in the network, it has initial resources located in both its neighboring nodes and its features. Initially, each feature and each neighboring node of nᵢ equally spread their resources to neighboring nodes. Subsequently, each of those nodes equally spreads its resources to neighbor nodes. Thus, nᵢ will obtain final resources located in several neighboring nodes, suggesting that nᵢ may have potential interactions with these nodes.\n\nReferences\n\nWu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.cutoff","page":"API","title":"SimSpread.cutoff","text":"cutoff(x::T, α::T, weighted::Bool=false) where {T<:AbstractFloat}\n\nTransform x based in SimSpread's similarity cutoff function.\n\nArguments\n\nx::AbstractFloat : Value to transform\nα::AbstractFloat : Similarity cutoff\nweighted::Bool : Apply weighting function to outcome (default = false)\n\n\n\n\n\ncutoff(M::AbstractVecOrMat{T}, α::T, weighted::Bool=false) where {T<:AbstractFloat}\n\nTransform the vector or matrix X based in SimSpread's similarity cutoff function.\n\nArguments\n\nX::AbstractVecOrMat{AbstractFloat} : Matrix or Vector to transform\nα::AbstractFloat : Similarity cutoff\nweighted::Bool : Apply weighting function to outcome (default = false)\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.cutoff!","page":"API","title":"SimSpread.cutoff!","text":"cutoff!(x::T, α::T, weighted::Bool=false) where {T<:AbstractFloat}\n\nTransform, in place, x based in SimSpread's similarity cutoff function.\n\nArguments\n\nx::AbstractFloat : Value to transform\nα::AbstractFloat : Similarity cutoff\nweighted::Bool : Apply weighting function to outcome (default = false)\n\n\n\n\n\ncutoff!(X::AbstractVecOrMat{T}, α::T, weighted::Bool=false) where {T<:AbstractFloat}\n\nTransform, in place, the vector or matrix X based in SimSpread's similarity cutoff function.\n\nArguments\n\nX::AbstractVecOrMat{AbstractFloat} : Matrix or Vector to transform\nα::AbstractFloat : Similarity threshold\nweighted::Bool : Apply weighting function to outcome (default = false)\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.featurize","page":"API","title":"SimSpread.featurize","text":"featurize(X::NamedArray, α::AbstractFloat, weighted::Bool=true)\n\nTransform the feature matrix X into a SimSpread feature matrix.\n\nArguments\n\nX::NamedArray: Continuous feature matrix\nα::AbstractFloat: Featurization cutoff\nweighted::Bool : Apply weighting function to outcome (default = true)\n\nReferences\n\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.featurize!","page":"API","title":"SimSpread.featurize!","text":"featurize!(X::NamedArray, α::AbstractFloat, weighted::Bool=true)\n\nTransform, in place, the feature matrix X into a SimSpread feature matrix.\n\nArguments\n\nX::NamedArray : Continuous feature matrix\nα::AbstractFloat : Featurization cutoff\nweighted::Bool : Apply weighting function to outcome (default = true)\n\nReferences\n\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.construct","page":"API","title":"SimSpread.construct","text":"construct(y::NamedMatrix, X::NamedMatrix, queries::AbstractVector)\n\nConstruct the query-feature-source-target network for de novo network-based inference prediction and return adjacency matrix.\n\nArguments\n\ny::NamedMatrix: Source-target bipartite network adjacency matrix\nX::NamedMatrix: Source-feature bipartite adjacency matrix\nqueries::AbstractVector: Source nodes to use as query\n\nExtended help\n\nThis implementation is intended for k-fold or leave-one-out cross-validation.\n\n\n\n\n\nconstruct(ys::T, Xs::T) where {T<:Tuple{NamedMatrix,NamedMatrix}}\n\nConstruct the query-feature-source-target network for de novo network-based inference prediction and return adjacency matrix.\n\nArguments\n\ndts::Tuple{NamedMatrix,NamedMatrix} : Source-target bipartite graph adjacency matrices\ndfs::Tuple{NamedMatrix,NamedMatrix} : Source-feature bipartite graph adjacency matrices\n\nExtended help\n\nThis implementations is intended for time-split cross-validation or manual construction of query network.\n\n\n\n\n\nconstruct(ytrain::T, ytest::T, Xtrain::T, Xtest::T) where {T<:NamedMatrix}\n\nConstruct the query-feature-source-target network for de novo network-based inference prediction and return adjacency matrix.\n\nArguments\n\nytrain::NamedMatrix : Training source-target bipartite graph adjacency matrix\nytest::NamedMatrix : Test source-target bipartite graph adjacency matrix\nXtrain::NamedMatrix : Training source-feature bipartite graph adjacency matrix\nXtest::NamedMatrix : Test source-feature bipartite graph adjacency matrix\n\nExtended help\n\nThis implementations is intended for time-split cross-validation or manual construction of query network.\n\n\n\n\n\nconstruct(y::NamedMatrix, X::NamedMatrix)\n\nConstruct the feature-source-target network for network-based inference prediction and return adjacency matrix.\n\nArguments\n\ny::NamedMatrix : Source-target bipartite graph adjacency matrix\nX::NamedMatrix : Source-feature bipartite graph adjacency matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.predict","page":"API","title":"SimSpread.predict","text":"predict(I::Tuple{T,T}, ytest::T; GPU::Bool=false) where {T<:NamedMatrix}\n\nPredict interactions between query and target nodes using de novo network-based inference model proposed by Wu, et al (2016).\n\nArguments\n\nI::Tuple{NamedMatrix,NamedMatrix}: Feature-source-target trilayered adjacency matrices\nytest::NamedMatrix: Query-target bipartite adjacency matrix\nGPU::Bool: Use GPU acceleration for calculation (default = false)\n\nReferences\n\nWu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\npredict(A::T, ytrain::T; GPU::Bool=false) where {T<:NamedMatrix}\n\nPredict interactions between query and target nodes using de novo network-based inference model proposed by Wu, et al (2016).\n\nArguments\n\nA::NamedMatrix: Feature-source-target trilayered adjacency matrix\nytrain::NamedMatrix: Source-target bipartite adjacency matrix\nGPU::Bool: Use GPU acceleration for calculation (default = false)\n\nReferences\n\nWu, et al (2016). SDTNBI: an integrated network and chemoinformatics tool for systematic prediction of drug–target interactions and drug repositioning. Briefings in Bioinformatics, bbw012. https://doi.org/10.1093/bib/bbw012\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.save","page":"API","title":"SimSpread.save","text":"save(filepath::String, yhat::NamedMatrix, y::NamedMatrix; delimiter::Char='\t')\n\nStore predictions as a table in the given file path.\n\nArguments\n\nfilepath::String: Output file path\nyhat::NamedArray: Predicted source-target bipartite adjacency matrix\ny::NamedArray: Ground-truth source-target bipartite adjacency matrix\ndelimiter::Char: Delimiter used to write table (default = '\\t')\n\nExtended help\n\nTable format is:\n\nfold, source, target, score, label\n\n\n\n\n\nsave(filepath::String, fidx::Int64, yhat::NamedMatrix, y::NamedMatrix; delimiter::Char='\t')\n\nStore cross-valudation predictions as a table in the given file path.\n\nArguments\n\nfilepath::String: Output file path\nfidx::Int64: Numeric fold ID\nyhat::NamedArray: Predicted source-target bipartite adjacency matrix\ny::NamedArray: Ground-truth source-target bipartite adjacency matrix\ndelimiter::Char: Delimiter used to write table (default = '\\t')\n\nExtended help\n\nTable format is:\n\nfold, source, target, score, label\n\n\n\n\n\n","category":"function"},{"location":"api/#Cross-validation","page":"API","title":"Cross-validation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"split\nclean!","category":"page"},{"location":"api/#Base.split","page":"API","title":"Base.split","text":"Base.split(y::NamedArray, k::Int64; seed::Int64=1)\n\nSplit source nodes in y into k groups for cross-validation.\n\nArguments\n\ny::AbstractMatrix: Drug-Target rectangular adjacency matrix.\nk::Int64: Number of groups to use in data splitting.\nseed::Int64: Seed used for data splitting.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.clean!","page":"API","title":"SimSpread.clean!","text":"clean!(yhat::NamedArray, A::NamedArray, y::NamedArray)\n\nFlag, in place, erroneous prediction from cross-validation splitting.\n\nArguments\n\nyhat::NamedArray: Predicted source-target bipartite adjacency matrix\nA::NamedArray: Initial resource source-target resources adjacency matrix\ny::NamedArray: Ground-truth source-target bipartite adjacency matrix\n\n\n\n\n\n","category":"function"},{"location":"api/#Performance-assessment","page":"API","title":"Performance assessment","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Several evaluation metrics are implemented in the package, which can be that can be classified into three groups: (i) overall performance, (ii) early recognition, and (iii) binary prediction  performance.","category":"page"},{"location":"api/#Overall-performance","page":"API","title":"Overall performance","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"This metrics represent classical evaluation metrics that make use of the complete list of prediction to assess predictive performance.","category":"page"},{"location":"api/","page":"API","title":"API","text":"AuPRC\nAuROC","category":"page"},{"location":"api/#SimSpread.AuPRC","page":"API","title":"SimSpread.AuPRC","text":"AuPRC(y::AbstractVector{Bool}, yhat::AbstractVector)\n\nArea under the Precision-Recall curve using the trapezoidal rule.\n\nArguments\n\ny::AbstractArray: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractArray: Prediction scores.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.AuROC","page":"API","title":"SimSpread.AuROC","text":"AuROC(y::AbstractVector{Bool}, yhat::AbstractVector)\n\nArea under the Receiver Operator Characteristic curve using the trapezoidal rule.\n\nArguments\n\ny::AbstractArray: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractArray: Prediction scores.\n\n\n\n\n\n","category":"function"},{"location":"api/#Early-recognition-performance","page":"API","title":"Early recognition performance","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Due to the roots of SimSpread (target prediction in drug discovery), we include evaluation metrics that aim to assess predictive performance of the best predictions obtained from a model.","category":"page"},{"location":"api/","page":"API","title":"API","text":"In virtual screening, only the best predictions obtained from a model are selected for posterior experimental validation. Therefore, understanding the predictive performance of a model for these predictions is essential to (1) make accurate predictions that will translate to biological activity and (2) understand the limitations of the model. The metrics discussed here can be evaluated at a given cut-off rank, considering only the topmost results returned by the predictive method, hence informing of the predictive performance of the model for only the best predictions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"recallatL\nprecisionatL\nBEDROC","category":"page"},{"location":"api/#SimSpread.recallatL","page":"API","title":"SimSpread.recallatL","text":"recallatL(y, yhat, L)\n\nGet recall@L as proposed by Wu, et al (2017).\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\nL::Integer: Length to consider to calculate metrics (default = 20).\n\n\n\n\n\nrecallatL(y, yhat, L)\n\nGet mean recall@L per group as proposed by Wu, et al (2017).\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\n̂grouping::AbstractVector: Group labels.\nL::Integer: Length to consider to calculate metrics (default = 20).\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.precisionatL","page":"API","title":"SimSpread.precisionatL","text":"precisionatL(y, yhat, L::Integer=20)\n\nGet precision@L as proposed by Wu, et al (2017).\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\nL::Integer: Length to consider to calculate metrics (default = 20).\n\n\n\n\n\nprecisionatL(y, yhat, grouping, L)\n\nGet mean precision@L per group as proposed by Wu, et al (2017).\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\ngrouping::AbstractVector: Group labels.\nL::Integer: Length to consider to calculate metrics (default = 20).\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.BEDROC","page":"API","title":"SimSpread.BEDROC","text":"BEDROC(y::AbstractVector{Bool}, yhat::AbstractVector; rev::Bool=true, α::AbstractFloat=20.0)\n\nThe Boltzmann Enhanced Descrimination of the Receiver Operator Characteristic (BEDROC) score is a modification of the Receiver Operator Characteristic (ROC) score that allows for a factor of early recognition.\n\nScore takes a value in interval [0, 1] indicating degree to which the predictive model employed detects (early) the positive class.\n\nArguments\n\ny::AbstractArray: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractArray: Prediction scores.\nrev::Bool: True if high values of yhat correlates to positive class (default = true).\nα::AbstractFloat: Early recognition parameter (default = 20.0).\n\nReferences\n\nTruchon, J.-F., & Bayly, C. I. (2007). Evaluating Virtual Screening Methods:  Good and\n\nBad Metrics for the “Early Recognition” Problem. Journal of Chemical Information and Modeling, 47(2), 488–508. https://doi.org/10.1021/ci600426e\n\n\n\n\n\n","category":"function"},{"location":"api/#Binary-prediction-performance","page":"API","title":"Binary prediction performance","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"A common practice in predictive modelling is to assign a score or probability threshold for the predictions obtained from a model and manually select or cherry-pick predictions for validation. In order to evaluate the predictive performance under this paradigm, we implement a series of metrics that are meant for binary classification, that is, a link exists or not  based in a given threshold, from which statistical moments can be calculated to retrieve a  notion of predictive performance as a decision boundary changes.","category":"page"},{"location":"api/","page":"API","title":"API","text":"f1score\nmcc\naccuracy\nbalancedaccuracy\nrecall\nprecision\nmeanperformance\nmeanstdperformance\nmaxperformance","category":"page"},{"location":"api/#SimSpread.f1score","page":"API","title":"SimSpread.f1score","text":"f1score(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe harmonic mean between precision and recall\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.mcc","page":"API","title":"SimSpread.mcc","text":"mcc(a::T, b::T, ϵ::AbstractFloat = 0.0001) where {T<:Integer}\n\nMatthews correlation coefficient using calculus approximation for when FN+TN, FP+TN, TP+FN or TP+FP equals zero.\n\nArguments\n\na::Integer = Value of position a in confusion matrix\nb::Integer = Value of position b in confusion matrix\nϵ::AbstractFloat = Approximation coefficient (default = floatmin(Float64))\n\nExtended help\n\nThe confusion matrix in a binary prediction is comprised of 4 distinct positions:\n\n                    | Predicted positive     Predicted negative\n    ----------------+--------------------------------------------\n    Actual positive |  True positives (TP)   False negatives (FN)\n    Actual negative | False positives (FP)    True negatives (TN)\n\nIn the case a row or column of the confusion matrix equals zero, MCC is undefined. Therefore, to correctly use MCC with this approximation, arguments a and b are defined as follows:\n\nIf \"Predictive positive\" column is zero, a is TN and b is FN\nIf \"Predictive negative\" column is zero, a is TP and b is FP\nIf \"Actual positive\" row is zero, a is TN and b is FP\nIf \"Actual negative\" row is zero, a is TP and b is FN\n\nReference\n\n1.Chicco, D., Jurman, G. The advantages of the Matthews correlation coefficient (MCC) over F1 score and accuracy in binary classification evaluation. BMC Genomics 21, 6 (2020).\n\n\n\n\n\nmcc(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nMatthews correlation coefficient, a special case of the phi coeficient Performance metric used for overcoming the class imbalance issues\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\nReference\n\n1.Chicco, D., Jurman, G. The advantages of the Matthews correlation coefficient (MCC) over F1 score and accuracy in binary classification evaluation. BMC Genomics 21, 6 (2020).\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.accuracy","page":"API","title":"SimSpread.accuracy","text":"accuracy(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe number of all correct predictions divided by the total predicitions\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.balancedaccuracy","page":"API","title":"SimSpread.balancedaccuracy","text":"balancedaccuracy(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe arithmetic mean of sensitivity and specificity, its use case is when dealing with imbalanced data\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.recall","page":"API","title":"SimSpread.recall","text":"recall(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe fraction of positive samples correctly predicted as postive\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.precision","page":"API","title":"SimSpread.precision","text":"precision(tn::T, fp::T, fn::T, tp::T) where {T<:Integer}\n\nThe fraction of positive predictions that are correct\n\nArguments\n\ntn::Integer True negatives\nfp::Integer False postives\nfn::Integer False negatives\ntp::Integer True positives\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.meanperformance","page":"API","title":"SimSpread.meanperformance","text":"meanperformance(confusion::AbstractVector{ROCNums{Int64}}, metric::Function)\n\nGet mean performance of a given metric over a set of confusion matrices.\n\nArguments\n\nconfusion::AbstractVector{ROCNums{Int64}}: Confusion matrices\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\nmeanperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)\n\nGet mean performance of a given metric over a pair of label-prediction vectors.\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction score.\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.meanstdperformance","page":"API","title":"SimSpread.meanstdperformance","text":"meanstdperformance(confusion::AbstractVector{ROCNums{Real}}, metric::Function)\n\nGet mean and standard deviation performance of a given metric over a set of confusion matrices.\n\nArguments\n\nconfusion::AbstractVector{ROCNums{Real}}: Confusion matrix object from MLBase\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\nmeanstdperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)\n\nGet mean and standard deviation performance of a given metric over a pair of label-prediction vectors.\n\nArguments\n\ny::AbstractVector: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector: Prediction scores.\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.maxperformance","page":"API","title":"SimSpread.maxperformance","text":"maxperformance(confusion::AbstractVector{ROCNums{Real}}, metric::Function)\n\nGet maximum performance of a given metric over a set of confusion matrices.\n\nArguments\n\nconfusion::AbstractVector{ROCNums{Real}}: Confusion matrices.\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\nmaxperformance(y::AbstractVector{Bool}, yhat::AbstractVector{Float64}, metric::Function)\n\nGet maximum performance of a given metric over a pair of label-prediction vectors.\n\nArguments\n\ny::AbstractVector{Bool}: Binary class labels. 1 for positive class, 0 otherwise.\n̂yhat::AbstractVector{Float64}: Prediction score.\n̂metric::Function: Performance metric function to use in evaluation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Other-metrics","page":"API","title":"Other metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"validity_ratio","category":"page"},{"location":"api/#SimSpread.validity_ratio","page":"API","title":"SimSpread.validity_ratio","text":"validity_ratio(yhat::AbstractVector)\n\nRatio of valid predictions (score > 0) and all predictions. Allows to check if predictive performance is given for all predictions or a subset of the predictions.\n\nArguments\n\nyhat::AbstractVector : Prediction scores.\n\nExtended help\n\nA limitation of SimSpread is that it is impossible to generate predictions for query nodes whose similarity to every source of the first network layer is below the similarity threshold α. In this case, the length of the feature vector is zero, resource spreading is not possible, and the predicted value is zero for all targets, therefore we need guardrails to correctly assess  performance as a function of the threshold α.\n\nThis characteristic of SimSpread can be seen as an intrinsic notion of its application domain. No target predictions are generated for query nodes outside SimSpread’s application domain instead of returning likely meaningless targets.\n\nReferences\n\nVigil-Vásquez & Schüller (2022). De Novo Prediction of Drug Targets and Candidates by Chemical Similarity-Guided Network-Based Inference. International Journal of Molecular Sciences, 23(17), 9666. https://doi.org/10.3390/ijms23179666\n\n\n\n\n\n","category":"function"},{"location":"api/#Miscellaneous-utilities","page":"API","title":"Miscellaneous utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"read_namedmatrix\nk\ngetyamanishi","category":"page"},{"location":"api/#SimSpread.read_namedmatrix","page":"API","title":"SimSpread.read_namedmatrix","text":"read_namedmatrix(filepath::String, valuetype::Type = FLoat64filepath::String, valuetype::Type)\n\nLoad a matrix with named indices as a NamedArray.\n\nArguments\n\nfilepath::String : File path of matrix to load\ndelimiter::Char : Delimiter character between values in matrix (default = ' ')\nvaluetype::Type : Type of values contained in matrix (default = Float64)\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.k","page":"API","title":"SimSpread.k","text":"k(G::AbstractMatrix)\n\nGet node degrees from adjacency matrix\n\nArguments\n\nM::AbstractMatrix : Matrix to parse\n\n\n\n\n\n","category":"function"},{"location":"api/#SimSpread.getyamanishi","page":"API","title":"SimSpread.getyamanishi","text":"getyamanishi(db)\n\nGet a tuple of matrices corresponding to the drug-target adjacency matrix and drug-drug similarity matrix for a given Yamanishi (2008) dataset.\n\nArguments\n\ndb: Dataset ID (any of the following: \"nr\", \"ic\", \"gpcr\" or \"e\")\n\nExample\n\njulia> dt, dd = getyamanishi(\"nr\");\n\njulia> dt[1:5, 1:5]\n5×5 Named Matrix{Float64}\n A ╲ B │  hsa190  hsa2099  hsa2100  hsa2101  hsa2103\n───────┼────────────────────────────────────────────\nD00040 │     0.0      0.0      0.0      0.0      0.0\nD00066 │     0.0      1.0      0.0      0.0      0.0\nD00067 │     0.0      1.0      0.0      0.0      0.0\nD00075 │     0.0      0.0      0.0      0.0      0.0\nD00088 │     0.0      0.0      0.0      0.0      0.0\n\njulia> dd[1:5, 1:5]\n5×5 Named Matrix{Float64}\n A ╲ B │   D00040    D00066    D00067    D00075    D00088\n───────┼─────────────────────────────────────────────────\nD00040 │      1.0  0.545455  0.297297   0.53125  0.459459\nD00066 │ 0.545455       1.0  0.387097  0.833333  0.689655\nD00067 │ 0.297297  0.387097       1.0  0.464286  0.352941\nD00075 │  0.53125  0.833333  0.464286       1.0  0.678571\nD00088 │ 0.459459  0.689655  0.352941  0.678571       1.0\n\nExtended help\n\nThe provided Yamanishi (2008) [1] datasets (ID) are:\n\n'Nuclear Receptor' (nr)\n'Ion Channels' (ic)\n'GPCR' (gpcr)\n'Enzyme' (e)\n\nThis function returns 2 distinct adjacency matrices:\n\nBinary drug-target interaction matrix, obtained from biological annotations\nContinuous drug-drug similarity matrix, obtained from SIMCOMP\n\nReferences\n\nYamanishi, Y., Araki, M., Gutteridge, A., Honda, W., & Kanehisa, M. (2008). Prediction of drug–target interaction networks from the integration of chemical and genomic spaces. Bioinformatics, 24(13), i232–i240. https://doi.org/10.1093/bioinformatics/btn162\n\n\n\n\n\n","category":"function"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"CurrentModule = SimSpread","category":"page"},{"location":"#SimSpread.jl","page":"Welcome to SimSpread.jl","title":"SimSpread.jl","text":"","category":"section"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"A package implementing the SimSpread formalism for link prediction.","category":"page"},{"location":"#Installation","page":"Welcome to SimSpread.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"SimSpread.jl can be installed typing","category":"page"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"Pkg.add(url=\"https://github.com/cvigilv/SimSpread.jl.git\", rev=\"develop\")","category":"page"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"in the Julia REPL.","category":"page"},{"location":"#Package-Features","page":"Welcome to SimSpread.jl","title":"Package Features","text":"","category":"section"},{"location":"","page":"Welcome to SimSpread.jl","title":"Welcome to SimSpread.jl","text":"Core implementation of SimSpread preditive algorithm\nHelper functions for preparation and construction of query graphs\nHelper function for cross-validation\nPerformance assessment metrics","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"EditURL = \"https://github.com/cvigilv/SimSpread.jl/blob/main/docs/src/tutorial/fishers-flowers.jl\"","category":"page"},{"location":"tutorial/fishers-flowers/#Fisher's-flowers","page":"Fisher's flowers","title":"Fisher's flowers","text":"","category":"section"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"In this tutorial, we will go through step by step in a more in depth workflow for using SimSpread.jl having as example the classic classification problem of R.A. Fisher iris dataset.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Let's go ahead and load the dataset we will work with, that is, the flower classes and features:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"using NamedArrays #hide\nusing SimSpread\n\ny = read_namedmatrix(\"data/iris.classes\")\nX = read_namedmatrix(\"data/iris.features\")\nsetdimnames!(y, [\"Flower\", \"Class\"]) #hide\nsetdimnames!(X, [\"Flower\", \"Feature\"]) #hide\nnothing #hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Classes are one-hot encoded due to how SimSpread works:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"y[1:5, :]","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"And features can be of any type (e.g., continuous floats describing the plants):","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"X[1:5, :]","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Next, we will train a model using SimSpread to predict the classes for a subset of plants in the Iris dataset. For this, we will split our dataset in 2 groups: training set, which will correspond to 90% of the data, and testing set, which will correspond to the remaining 10%:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"using Random #hide\nRandom.seed!(1) #hide\nnflowers = size(y, 1)\n\ntrain = rand(nflowers) .< 0.9\ntest = .!train\n\nytrain = y[train, :]\nytest = y[test, :]\nnothing#hide","category":"page"},{"location":"tutorial/fishers-flowers/#Meta-description-preparation","page":"Fisher's flowers","title":"Meta-description preparation","text":"","category":"section"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"As we previously mentioned, SimSpread uses an abstracted feature set where entities are described by their similarity to other entities. This permits the added flexibility of freely choosing any type of features and similarity measurement to correctly describe the problems entities.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"To generate this meta-description features, the following steps are taken:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"A similarity matrix S is obtained from the calculation of a similarity metric between all pairs of feature vectors of the entities on the studied dataset:\nFrom S we can construct a similarity-based feature matrix S^prime by applying the similarity threshold alpha using the following equation: S^prime_ij=w(ij)  textif  S_ij ge alpha  0  textotherwise where S corresponds to the entities similarity matrix, S^prime to the final feature matrix, i and j to entities in the studied dataset, and w(ij) the weighting scheme employed for feature matrix construction, which can be binary, w(ij) = S_ij  0, or continuous, w(ij) = (S_ij  0) times S_ij.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"This meta-description matrix encodes the question \"Is plant i similar to plant j?\", which is later used by the resource spreading algorithm for link prediction.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Here, we will use the Jaccard index as our similarity measure, similarity measurement that is bound between 0 and 1, and will use a cutoff of J(xy) = 09, since this will conserve all comparison between highly similar flowers:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"using CairoMakie#hide\nusing Distances, NamedArrays\n\nS = NamedArray(1 .- pairwise(Jaccard(), X, dims=1))\nf = Figure(resolution=(600, 500)) #hide\naxdd, hmdd = heatmap(f[1, 1], S.array'; colorrange=(0, 1), colormap=:binary) #hide\nColorbar(f[1, 2], hmdd; label=\"Jaccard similarity\") #hide\naxdd.title = \"Flower similarity\" #hide\naxdd.xlabel = \"Flower\" #hide\naxdd.ylabel = \"Flower\" #hide\ncolsize!(f.layout, 1, Aspect(1, 1.0)) #hide\nf#hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"From this similarity matrix, we will prepare our meta-description for both training and testing sets:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"heatmaps(M::NamedArray, N::NamedArray) = begin #hide\n    f = Figure(resolution=(700, 300)) #hide\n    axold, _ = heatmap(f[1, 1], M.array'; colorrange=(0, 1), colormap=:binary) #hide\n    axnew, hmnew = heatmap(f[1, 2], N.array'; colorrange=(0, 1), colormap=:binary) #hide\n    Colorbar(f[1, 3], hmnew; label=\"Jaccard Similarity\") #hide\n    axold.title = \"Before\" #hide\n    axnew.title = \"After\" #hide\n    axold.xlabel = \"Flowers\" #hide\n    axold.ylabel = \"Flowers\" #hide\n    axnew.xlabel = \"Flowers\" #hide\n    axnew.ylabel = \"Flowers\" #hide\n    colsize!(f.layout, 1, Aspect(1, 1.0)) #hide\n    colsize!(f.layout, 2, Aspect(1, 1.0)) #hide\n    return f #hide\nend; #hide\n\nα = 0.9\nXtrain = featurize(S[train, train], α, true)\nXtest = featurize(S[test, train], α, true)\nnothing #hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Training set meta-description matrix:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"heatmaps(S[train, train], Xtrain) #hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Testing set meta-description matrix:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"heatmaps(S[test, train], Xtest) #hide","category":"page"},{"location":"tutorial/fishers-flowers/#Predicting-labels-with-SimSpread","page":"Fisher's flowers","title":"Predicting labels with SimSpread","text":"","category":"section"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Now that we have all the information necessary for SimSpread, we can construct the query graph that is used to predict links using network-based-inference resource allocation algorithm.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"In first place, we need to construct the query network for label prediction:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"G = construct(ytrain, ytest, Xtrain, Xtest)\nnothing#hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"From this, we can predict the labels as follows:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"ŷtrain = predict(G, ytrain)\nŷtest = predict(G, ytest)\nnothing #hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Let's visualize the predictions obtained from our model:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"heatmaps(M::NamedArray, N::NamedArray) = begin #hide\n    M′ = M' #./ maximum(M; dims=2))' #hide\n    N′ = N' #./ maximum(N; dims=2))' #hide\n    @show maxscore = maximum([maximum(vec(M)), maximum(vec(N))]) #hide\n    f = Figure(resolution=(700, 300)) #hide\n    axold = Axis(#hide\n        f[1, 1],#hide\n        title=\"Ground-truth\", #hide\n        xlabel=\"Class\", #hide\n        ylabel=\"Flowers\", #hide\n        xticks=(1:3, names(y, 2)), #hide\n        xticklabelrotation=π / 4, #hide\n    )\n    axnew = Axis(\n        f[1, 2],\n        title=\"Predictions\",\n        xlabel=\"Class\",\n        ylabel=\"Flowers\",\n        xticks=(1:3, names(y, 2)), #hide\n        xticklabelrotation=π / 4 #hide\n    )\n    heatmap!(axold, M′.array; colorrange=(0, maxscore), colormap=:binary) #hide\n    hmnew = heatmap!(axnew, N′.array; colorrange=(0, maxscore), colormap=:binary) #hide\n\n    Colorbar(f[1, 3], hmnew; label=\"SimSpread score\") #hide\n    colsize!(f.layout, 1, Aspect(1, 1.0)) #hide\n    colsize!(f.layout, 2, Aspect(1, 1.0)) #hide\n    return f #hide\nend; #hide\nnothing #hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Training set:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"heatmaps(ytrain, ŷtrain) #hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Testing set:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"heatmaps(ytest, ŷtest) #hide","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"As we can see, we predict the probability for each class of flower possible. To evaluate the predictive performance as a multiclass problem, we will assign the label with the highest score as the predicted label.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"In the example above, the predicted labels for each row in the matrix would be \"Iris-virginica\" (C3), \"Iris-setosa\" (C1) & \"Iris-setosa\" (C1).","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"To convert the problem from single-class to multi-class, we do the following:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"class_mapper = [\"Iris-setosa\", \"Iris-versicolor\", \"Iris-virginica\"]\n\nŷ = hcat(\n    vcat(test_idx, train_idx),\n    vcat(\n        [class_mapper[cidx] for (_, cidx) in Tuple.(argmax(ŷtest, dims=2))],\n        [class_mapper[cidx] for (_, cidx) in Tuple.(argmax(ŷtrain, dims=2))]\n    )\n)\n\nfirst(ŷ[:, 2], 3)","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Great! Our predicted labels match what we expected. Now let's assess how good is SimSpread in predicting the classes for the iris dataset.","category":"page"},{"location":"tutorial/fishers-flowers/#Assesing-the-predictive-performance-of-the-proposed-model","page":"Fisher's flowers","title":"Assesing the predictive performance of the proposed model","text":"","category":"section"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"In order to have an idea of the predictive performance of the model we constructed, we will use two common metrics in multi-class prediction problems to evaluate the predictions for both the training and testing sets:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Accuracy, that indicates how close a given set of predictions are to their true","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"value, and 2. Error rate, that indicates the inverse of accuracy.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Let's start with accuracy:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"using AlgebraOfGraphics, CairoMakie\nset_aog_theme!()\n\ndf = (\n    train=[Bool(i ∈ train_idx) for i in 1:N],\n    y=y,\n    yhat=ŷ[sortperm(ŷ[:, 1]), 2]\n)\n\nplt = data(df)\nplt *= expectation()\nplt *= mapping(\n    :y => \"Class\",\n    (:y, :yhat) => isequal => \"Accuracy\"\n)\nplt *= mapping(\n    dodge=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\",\n    color=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\"\n)\n\ndraw(plt; axis=(width=400, height=225))","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"As we can see, our proposed SimSpread model achieves high accuracy for both training and testing sets. Let's see the error rates for the same grouping:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"plt = data(df)\nplt *= expectation()\nplt *= mapping(\n    :y => \"Class\",\n    (:y, :yhat) => !isequal => \"Error rate\"\n)\nplt *= mapping(\n    dodge=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\",\n    color=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\"\n)\n\ndraw(plt; axis=(width=400, height=225))","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Here we also see goo performance, achieving low error rate for all the classes in both the training and testing sets. We also can appreciate that the the testing set present a higher mean error rate than the training set.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Let's visualize where the predicted classes fall in our training and testing sets. First, lets see our ground truth:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"df = (\n    sepallength=S[!, \"sepallength\"],\n    petallength=S[!, \"petallength\"],\n    y=iris[!, \"class\"],\n)\nplt = data(df)\nplt *= mapping(\n    :sepallength => \"Sepal Length (cm)\",\n    :petallength => \"Petal Length (cm)\",\n    color=:y => \"Class\"\n)\ndraw(plt; axis=(width=300, height=300))","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"We can clearly see that setosa plants are completely separated from the rest of the plants in the dataset. Versicolor and virginica present some overlap, which might respond to what we have see in the predictive performance.","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"Let's visualize the prediction over this scatter plot to map where are the incorrect predictions:","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"df = (\n    sepallength=S[!, \"sepallength\"],\n    petallength=S[!, \"petallength\"],\n    train=[Bool(i ∈ train_idx) for i in 1:N],\n    y=iris[!, \"class\"],\n    yhat=ŷ[sortperm(ŷ[:, 1]), 2]\n)\n\nplt = data(df)\nplt *= mapping(\n    :sepallength => \"Sepal Length (cm)\",\n    :petallength => \"Petal Length (cm)\",\n    row=:train => renamer(true => \"Training set\", false => \"Testing set\") => \"Dataset\",\n    col=:y => \"Class\",\n    color=:yhat => \"Predicted class\"\n)\n\ndraw(plt; axis=(width=225, height=225))","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"","category":"page"},{"location":"tutorial/fishers-flowers/","page":"Fisher's flowers","title":"Fisher's flowers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"EditURL = \"https://github.com/cvigilv/SimSpread.jl/blob/main/docs/src/tutorial/getting-started.jl\"","category":"page"},{"location":"tutorial/getting-started/#Getting-started-with-SimSpread.jl","page":"Getting started","title":"Getting started with SimSpread.jl","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"SimSpread is a novel approach for predicting interactions between two distinct set of nodes, query and target nodes, using a similarity measure vector between query nodes as a meta-description in combination with the network-based inference for link prediction.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"In this tutorial, we will skim through the basic workflow for using SimSpread.jl using as an example the prediction of dug-target interactions for the Nuclear Receptor dataset from Yamanishi, et al (2008).","category":"page"},{"location":"tutorial/getting-started/#Preparing-our-problem","page":"Getting started","title":"Preparing our problem","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"First, we will download the known drug-target interaction matrix and drug-drug SIMCOMP similarity matrix for the 'Nuclear Receptor' dataset. The package provides a helper for easy download and preparation for this group of datasets (refer to ??getyamanishi for more information).","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"using CairoMakie #hide\nusing NamedArrays # hide\nCairoMakie.activate!() # hide\nusing SimSpread\n\nDT, DD = getyamanishi(\"nr\")\nnothing #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Let's visualize our data as heatmaps:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"heatmaps(M::NamedArray, N::NamedArray) = begin #hide\n    M′ =  M' #hide\n    N′ =  N' #hide\n    f = Figure(resolution=(700, 300)) #hide\n    axdt, _ = heatmap(f[1, 1], M′.array; colorrange=(0, 1), colormap=:binary) #hide\n    axdd, hmdd = heatmap(f[1, 2], N′.array; colorrange=(0, 1), colormap=:binary) #hide\n    Colorbar(f[1, 3], hmdd; label=\"SIMCOMP similarity\") #hide\n    axdt.title = \"Drug-Target\\ninteractions\" #hide\n    axdd.title = \"Drug-Drug\\nsimilarity\" #hide\n    axdt.xlabel = \"Targets\" #hide\n    axdt.ylabel = \"Drugs\" #hide\n    axdd.xlabel = \"Drugs\" #hide\n    axdd.ylabel = \"Drugs\" #hide\n    colsize!(f.layout, 1, Aspect(1, 1.0)) #hide\n    colsize!(f.layout, 2, Aspect(1, 1.0)) #hide\n    return f #hide\nend; #hide\nheatmaps(DT, DD) #hide","category":"page"},{"location":"tutorial/getting-started/#Data-splitting","page":"Getting started","title":"Data splitting","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Next, we will train a model using SimSpread to predict the targets for a subset of drugs in the dataset. For this, we will split our dataset in 2 groups: training set, which will correspond to 90% of the data, and testing set, which will correspond to the remaining 10%:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"using Random #hide\nRandom.seed!(1) #hide\nN = size(DT, 1)\n\ntrain = rand(N) .< 0.9\ntest = .!train\n\nytrain = DT[train, :]\nytest = DT[test, :]\nnothing #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"println(\"Training set size: \", size(ytrain)) #hide\nprintln(\"Testing set size:  \", size(ytest)) #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"As seen here, around 90% of the dataset corresponds to training and the remaining to testing sets. From this splitting we will proceed to construct our query network and predict the interactions for the testing set.","category":"page"},{"location":"tutorial/getting-started/#Similarity-based-meta-description-preparation","page":"Getting started","title":"Similarity-based meta-description preparation","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"SimSpread uses a meta-description constructed from the similarity between source nodes (drugs in the working example). For this, a similarity threshold (denoted with α) is employed to keep links between source nodes that have a weight greater or equal to this threshold.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"This procedure encodes the question \"Is drug i similar to drug j?\", which is later used by the resource spreading algorithm for link prediction.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"α = 0.35\nXtrain = featurize(DD[train, train], α, false)\nXtest = featurize(DD[test, train], α, false)\nnothing #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Let's compare the similarity matrices before and after the featurization procedure:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Training set:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"heatmaps(M::NamedArray, N::NamedArray) = begin #hide\n    f = Figure(resolution=(700, 300)) #hide\n    axold, _  = heatmap(f[1, 1], M.array; colorrange=(0, 1), colormap=:binary) #hide\n    axnew, hmnew = heatmap(f[1, 2], N.array; colorrange=(0, 1), colormap=:binary) #hide\n    Colorbar(f[1, 3], hmnew; label=\"Similarity\") #hide\n    axold.title = \"Before\" #hide\n    axnew.title = \"After\" #hide\n    axold.xlabel = \"Drugs\" #hide\n    axold.ylabel = \"Drugs\" #hide\n    axnew.xlabel = \"Drugs\" #hide\n    axnew.ylabel = \"Drugs\" #hide\n    colsize!(f.layout, 1, Aspect(1, 1.0)) #hide\n    colsize!(f.layout, 2, Aspect(1, 1.0)) #hide\n    return f #hide\nend; #hide\n\nheatmaps(DD[train, train], Xtrain) #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Testing set:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"heatmaps(DD[test, train], Xtest) #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"As seen here, all comparisons with a weight lower than our threshold α are eliminated (i.e. filled with a zero, 0) and a structure arises from this new featurized matrix.","category":"page"},{"location":"tutorial/getting-started/#Predicting-DTIs-with-SimSpread","page":"Getting started","title":"Predicting DTIs with SimSpread","text":"","category":"section"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Now that we have all the information necessary for SimSpread, we can construct the query graph that is used to predict links using network-based-inference resource allocation algorithm.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"In first place, we need to construct the query network for label prediction:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"G = construct(ytrain, ytest, Xtrain, Xtest)\nnothing #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"From this, we can predict the labels as follows:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"ŷtrain = predict(G, ytrain)\nŷtest = predict(G, ytest)\nnothing #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Finally, we assess the performance of our model using the area under ROC curve, denoted as AuROC:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"println(\"AuROC training set: \", round(AuROC(Bool.(vec(ytrain)), vec(ŷtrain)); digits=3)) #hide\nprintln(\"AuROC testing set:  \", round(AuROC(Bool.(vec(ytest)), vec(ŷtest)); digits=3)) #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Let's visualize the predictions obtained from our model:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Training set:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"heatmaps(M::NamedArray, N::NamedArray) = begin #hide\n    M′ =  M' #./ maximum(M; dims=2))' #hide\n    N′ =  N' #./ maximum(N; dims=2))' #hide\n    @show maxscore = maximum([maximum(vec(M)), maximum(vec(N))]) #hide\n    f = Figure(resolution=(700, 300)) #hide\n    axold, _ = heatmap(f[1, 1], M′.array; colorrange=(0, maxscore), colormap=:binary) #hide\n    axnew, hmnew = heatmap(f[1, 2], N′.array; colorrange=(0, maxscore), colormap=:binary) #hide\n    Colorbar(f[1, 3], hmnew; label=\"SimSpread score\") #hide\n    axold.title = \"Ground-truth\" #hide\n    axnew.title = \"Predictions\" #hide\n    axold.xlabel = \"Targets\" #hide\n    axold.ylabel = \"Drugs\" #hide\n    axnew.xlabel = \"Targets\" #hide\n    axnew.ylabel = \"Drugs\" #hide\n    colsize!(f.layout, 1, Aspect(1, 1.0)) #hide\n    colsize!(f.layout, 2, Aspect(1, 1.0)) #hide\n    return f #hide\nend; #hide\nheatmaps(ytrain, ŷtrain) #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"Testing set:","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"heatmaps(ytest, ŷtest) #hide","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"This wraps up our tutorial. The following tutorial provided (i) a more in-depth use case of the core utilities of SimSpread.jl and (ii) how to optimize a SimSpread model and evaluate its predictions. Adittionally, recipes for common ML tasks are provided in the next sections, specifically, common corss-validation scenarios.","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorial/getting-started/","page":"Getting started","title":"Getting started","text":"This page was generated using Literate.jl.","category":"page"}]
}
